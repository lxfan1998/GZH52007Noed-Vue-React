<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>async</title>
</head>
<body>

</body>
<script>
    // $.ajax({
    //     url: '',
    //     method: 'POST',
    //     datatype: 'json',
    //     success: data => {
    //         ;
    //     },
    //     error: err => {
    //         ;
    //     }
    // })

    // ajax(url,type,function(){

    // })

    // 解决回调地狱的问题，引入Promise
    // let p=new Promise((resolve,reject)=>{
    //     // 异步的代码
    //     setTimeout(function(){
    //         resolve('调用');
    //     },1000);
    // });

    // p.then(data=>{
    //     // 接收成功的数据
    // }).catch(err=>{
    //     // 接收失败的数据
    // });

    // 返回一个Promise对象
    // 调用query()得到的是一个Promise对象
    function query(sql){
        return new Promise((resolve,reject)=>{
            pool.query(sql,(err,data)=>{
                if(err) reject(err);  //如果有错误就返回错误
                resolve(data);  //实参，回调函数把data数据传到声明体
            });
        });
    }

    // ES7的写法：async await
    // let p=new Promise((resolve,reject)=>{
    //     // 异步的代码
    //     setTimeout(function(){
    //         resolve('调用');
    //     },1000);
    // });

    // 老的写法，回调写法，容易出现回调地狱
    let p1=query();
    p1.then(data=>{
        // 使用成功返回的数据
    }).catch(err=>{
        // 捕获错误
    });

    // ES7的写法 async await
    // await一定要在async函数中使用
    async function getdata(){
        let data=await query();
        // data就是Promise成功返回的数据
        // 等到数据后，再使用数据
        // 缺点：只接收resolve的数据，不能获取到reject的数据
    }

    // async await 捕获异常
    async function getdata(){
        try {
            let data=await query();
            // 写在回调里面，用同步的方式实现了异步的效果
        } catch (error) {
            // 获取到reject处理的数据
        }
    }
</script>
</html>